---
title: "Figures - Covertype Dataset"
author: "Pablo Morala"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

####################################
# 1 - Load all needed packages and functions
####################################
# core
library(nn2poly)
library(nn2poly.tools)
library(keras)
library(tensorflow)

#plots
library(ggplot2)
library(cowplot)
library(viridis)
library(patchwork)

# Others
library(tidytext)
library(kableExtra)

IEEE_width_inches <- 3.5
my_width <- IEEE_width_inches

my_seed <- 42
set.seed(my_seed)
tensorflow::tf$random$set_seed(my_seed) # Needed to have reproducible results with keras
```


# Load results


```{r}

output1 = readRDS("data/Covertype_max_Q_1_results")

output2 = readRDS("data/Covertype_max_Q_2_results")

output3 = readRDS("data/Covertype_max_Q_3_results")


# polynomials
final_poly1 <- output1$final_poly
final_poly2 <- output2$final_poly
final_poly3 <- output3$final_poly

# Obtain the predicted values with the NN to compare them
prediction_NN_class <- output2$prediction_NN_class
prediction_NN <- output2$prediction_NN

# Predictions from both polynomials:

prediction_poly1_matrix <- output1$prediction_poly_matrix
prediction_poly1_class <- output1$prediction_poly_class

prediction_poly2_matrix <- output2$prediction_poly_matrix
prediction_poly2_class <- output2$prediction_poly_class


prediction_poly3_matrix <- output3$prediction_poly_matrix
prediction_poly3_class <- output3$prediction_poly_class

test_y <-output2$test_y

```



# MSE before softmax activation

We can obtain the MSE between NN predictions and both polynomial predictions:

```{r}
n_test <- length(test_y)
n_class <- dim(final_poly2$values)[1]

MSE_per_class1 <- vector(mode = "numeric", length(n_class))
MSE_per_class2 <- vector(mode = "numeric", length(n_class))
MSE_per_class3 <- vector(mode = "numeric", length(n_class))
for (k in 1:n_class){
  
  MSE_per_class1[k] <- sum((prediction_NN[,k] - prediction_poly1_matrix[k,])^2) / n_test
  MSE_per_class2[k] <- sum((prediction_NN[,k] - prediction_poly2_matrix[k,])^2) / n_test
  MSE_per_class3[k] <- sum((prediction_NN[,k] - prediction_poly3_matrix[k,])^2) / n_test
  
}

MSE_per_class1
MSE_per_class2
MSE_per_class3
```
Store results in dataframe to create a table:

```{r}
MSE_table <- data.frame(
  type = 1:7,
  MSE_1 = MSE_per_class1,
  MSE_2 = MSE_per_class2,
  MSE_3 = MSE_per_class3
)

MSE_table



library(dplyr)
MSE_table %>% mutate(across(where(is.numeric), ~ round(., 6)))
```


```{r}
length(final_poly1$labels)
length(final_poly2$labels)
length(final_poly3$labels)
```



Latex Table:

```{r, results='asis'}
MSE_table %>% mutate(across(where(is.numeric), ~ round(., 6))) %>%
  kbl(
    caption = "MSE between NN prediction and polynomial prediction for each forest type (previous to softmax)",
    format = "latex",
    col.names = c("Forest Type", "MSE 1st order order", "MSE 2nd order", "MSE 3rd order"),
    align = "c"
  )
```




# Confussion Matrix

Confusion matrix for both polynomials compared with nn predictions and confusion matrix for nn predictions against original values.



```{r}

# Confussion matrix between NN class prediction and polynomial class prediction
cm <- caret::confusionMatrix(as.factor(prediction_NN_class), as.factor(test_y))
cm

# Confussion matrix between NN class prediction and polynomial class prediction
cm1 <- caret::confusionMatrix(as.factor(prediction_NN_class), as.factor(prediction_poly1_class ))
cm1

# Confussion matrix between NN class prediction and polynomial class prediction
cm2 <- caret::confusionMatrix(as.factor(prediction_NN_class), as.factor(prediction_poly2_class ))
cm2

# Confussion matrix between NN class prediction and polynomial class prediction
cm3 <- caret::confusionMatrix(as.factor(prediction_NN_class), as.factor(prediction_poly3_class ))
cm3


cm4 <- caret::confusionMatrix(as.factor(prediction_poly2_class ),as.factor(test_y))
cm4
```

```{r}
cm1$overall
cm2$overall
cm3$overall
```




```{r}
cm1$table
```



Helper used to write Latex Table

```{r}
M <- cm1$table

str_vec <- vector()
for (i in 1:nrow(M)){
  Mrow <- M[i,]
  str <- ""
  for(j in 1:length(Mrow)){
    str <- paste(str,"&")
    str <- paste(str, Mrow[j])
  }
  str_vec[i] <- str
}

str_vec
```

Explore the polynomials:

```{r}

M <- final_poly1$values

# For each row, we have a different polynomial so we need to plot them
# separately

n_important_coeffs <- 10
plot_list <- list()

for (r in 1:nrow(M)){
  Mr <- M[r,]
  aux_total <- sort(abs(Mr),decreasing = TRUE, index.return = TRUE)
  aux_values <- aux_total$x[1:n_important_coeffs]
  aux_index <- aux_total$ix[1:n_important_coeffs]
  
  # Obtain labels:
  list_labels <- final_poly2$labels[aux_index]

  string_labels <- rep("0",n_important_coeffs)
  for (i in 1:n_important_coeffs) {
    # Create the label as a string of the form "l_1 l_2 ... l_t"
    string_labels[i] <- paste(as.character(list_labels[[i]]), collapse = ",")
  }

  aux_sign <- sign(Mr)[aux_index]
  
  data <- data.frame(
    name=string_labels,
    sign = as.factor(aux_sign),
    value=aux_values
  )
  
  # Plot: 
  plot_important_coeffs <- ggplot(data, aes(x=reorder(name, -value), y=value, fill=sign)) +
      geom_bar(stat="identity", colour = "black",  alpha=1) +
      cowplot::theme_half_open()+
      scale_fill_manual(values = c("#F8766D","#00BA38"))+
      labs(y = "Coefficient (absolute) values", x = "Variables or interactions")+
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
      theme(legend.position = c(0.5, 0.8), legend.direction = "horizontal") +
      labs(fill = "Coefficient sign")
  
  plot_list[[r]] <- plot_important_coeffs
}

plot_list
```


# Combined plots:


```{r}

M <- final_poly1$values

# For each row, we have a different polynomial so we need to plot them
# separately

n_important_coeffs <- 10

all_df <- data.frame()

for (r in 1:nrow(M)){
  Mr <- M[r,]
  aux_total <- sort(abs(Mr),decreasing = TRUE, index.return = TRUE)
  aux_values <- aux_total$x[1:n_important_coeffs]
  aux_index <- aux_total$ix[1:n_important_coeffs]
  
  # Obtain labels:
  list_labels <- final_poly2$labels[aux_index]

  string_labels <- rep("0",n_important_coeffs)
  for (i in 1:n_important_coeffs) {
    # Create the label as a string of the form "l_1 l_2 ... l_t"
    string_labels[i] <- paste(as.character(list_labels[[i]]), collapse = ",")
  }

  aux_sign <- sign(Mr)[aux_index]
  
  df <- data.frame(
    name=string_labels,
    sign = as.factor(aux_sign),
    value=aux_values,
    type = r
  )
  
  all_df <- rbind(all_df,df)
}

plot_all <- ggplot(all_df, aes(x=reorder_within(x = name, by = -value, within = type), y=value, fill=sign)) +
      geom_bar(stat="identity", colour = "black",  alpha=1) +
      scale_x_reordered() +
      facet_wrap(~type, scales = "free_x") +
      cowplot::theme_half_open() +
      labs(y = "Coefficient (absolute) values", x = "Variables or interactions") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
      scale_fill_manual(values = c("#F8766D","#00BA38"), labels = c("-","+"))+
      theme(legend.position = c(1, 0), legend.direction = "horizontal", legend.justification = c(1, 0)) +
      labs(fill = "Sign")


plot_all

```



```{r}

# Save as pdf as to avoid problems in arxiv
pdf(file="temporal/fig_covertype_coeffs.pdf", width = 2*my_width, height = 2*my_width)
plot_all
dev.off()
```














