---
title: "Figures - Covertype Dataset"
author: "Pablo Morala"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

####################################
# 1 - Load all needed packages and functions
####################################
library(nn2poly)
library(nn2poly.tools)
library(keras)
library(tensorflow)
library(cowplot)
library(ggplot2)

IEEE_width_inches <- 3.5
my_width <- IEEE_width_inches

my_seed <- 42
set.seed(my_seed)
tensorflow::tf$random$set_seed(my_seed) # Needed to have reproducible results with keras
```


# Load results


```{r}

output2 = readRDS("temporal/Covertype_max_Q_2_results")

output3 = readRDS("temporal/Covertype_max_Q_3_results")

nn <- load_model_tf("temporal/Covertype_nn")

nn

probability_nn <- keras_model_sequential() %>%
  nn %>%
  layer_activation_softmax() %>%
  layer_lambda(k_argmax)

probability_poly <- keras_model_sequential() %>%
  layer_activation_softmax() %>%
  layer_lambda(k_argmax)

test_x <- output2$test_x
test_y <- output2$test_y

final_poly2 <- output2$final_poly
final_poly3 <- output3$final_poly

```



# Obtain predictions:


```{r}


# Obtain the predicted values with the NN to compare them
prediction_NN_class <- predict(probability_nn, test_x)
prediction_NN <- predict(nn, test_x)

# Predictions from both polynomials:
prediction_poly2_matrix <- eval_poly(x = test_x, poly = final_poly2)
prediction_poly2_class <- predict(probability_poly,t(prediction_poly2_matrix))

prediction_poly3_matrix <- eval_poly(x = test_x, poly = final_poly3)
prediction_poly3_class <- predict(probability_poly,t(prediction_poly3_matrix))



```


```{r}

```



Confusion matrix for both polynomials compared with nn predictions and confusion matrix for nn predictions against original values.



```{r}


# Confussion matrix between NN class prediction and polynomial class prediction
cm2 <- caret::confusionMatrix(as.factor(prediction_NN_class), as.factor(prediction_poly2_class ))
cm2

# Confussion matrix between NN class prediction and polynomial class prediction
cm3 <- caret::confusionMatrix(as.factor(prediction_NN_class), as.factor(prediction_poly3_class ))
cm3


```




We are going to save this confusion matrix data as a Latex Table


```{r}

```





Explore the polynomals:




```{r}


n_sims <- 1

string_labels <- rep("0",length())
for (i in 1:length(simulations[[1]]$labels)) {
    # Create the label as a string of the form "l_1 l_2 ... l_t"
    string_labels[i] <- paste(as.character(simulations[[1]]$labels[[i]]), collapse = ",")
}

M <- matrix(1, n_sims, length(simulations[[1]]$labels))

colnames(M) <- string_labels

for (sim in 1:n_sims){
  coefs <- simulations[[sim]]$coeffs
  
  M[sim, ] <- coefs
}

M <- as.data.frame(M)



# perform the mean to obtain the order using the mean:
aux_total <- sort(abs(colMeans(M)),decreasing = TRUE, index.return = TRUE)
aux <- aux_total$x[1:20]
aux_index <- aux_total$ix[1:20]


df <- matrix(aux, nrow = 1)

aux_sign <- sign(colMeans(M))[aux_index]
 
df <- rbind(df,aux_sign)
colnames(df) <- names(aux)
rownames(df) <- c("mean","sign")

df <- as.data.frame(df)

df
# We need to precompute the "error" for the graph. In this case we will use standard deviation:


library(dplyr)
M_sd <- M %>% summarise_if(is.numeric, sd)

my_sd <- as.matrix(M_sd[,names(aux)])

my_sd <- as.vector(my_sd)



data <- data.frame(
  name=names(aux),
  Sign = as.factor(aux_sign),
  value=unname(aux),
  sd=my_sd
)


```

```{r}
# Plot: 
plot_error_bars <- ggplot(data, aes(x=reorder(name, -value), y=value, fill=Sign)) +
    geom_bar( stat="identity", colour = "black",  alpha=1) +
    geom_errorbar( aes(x=name, ymin=value-sd, ymax=value+sd), width=0.3, colour="black", alpha=0.9, size=1.3) + 
    cowplot::theme_half_open()+
    labs(y = "Coefficient (absolute) values", x = "Variables or interactions")+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    theme(legend.position = c(0.5, 0.8), legend.direction = "horizontal") +
    labs(fill = "Coefficient sign")
    

plot_error_bars
```










-------------------------------


```{r}




plot_performance <- cowplot::plot_grid(output1$plot_NN_performance, output1$plot_PR_vs_NN + ggplot2::labs(x = "Predicted Y with polynomial"), labels = c("A", "B"), scale = 0.9, label_size = 10)

plot_performance


```



```{r}
# Save the plot in temporal file
setEPS()
postscript("temporal/fig_Boston_NN_performance.eps", width = 2*my_width, height = 1*my_width)
plot_performance
dev.off()

# Save as pdf as to avoid problems in arxiv
pdf(file="temporal/fig_Boston_NN_performance.pdf", width = 2*my_width, height = 1*my_width)
plot_performance
dev.off()
```



# 1 NNs and average coeffs.

Create Df for other plots:

The 20 selected are not the same in all the cases, and not same order. So maybe compute mean 

```{r}


n_sims <- length(simulations)

string_labels <- rep("0",length(simulations[[1]]$labels))
for (i in 1:length(simulations[[1]]$labels)) {
    # Create the label as a string of the form "l_1 l_2 ... l_t"
    string_labels[i] <- paste(as.character(simulations[[1]]$labels[[i]]), collapse = ",")
}

M <- matrix(1, n_sims, length(simulations[[1]]$labels))

colnames(M) <- string_labels

for (sim in 1:n_sims){
  coefs <- simulations[[sim]]$coeffs
  
  M[sim, ] <- coefs
}

M <- as.data.frame(M)



# perform the mean to obtain the order using the mean:
aux_total <- sort(abs(colMeans(M)),decreasing = TRUE, index.return = TRUE)
aux <- aux_total$x[1:20]
aux_index <- aux_total$ix[1:20]


df <- matrix(aux, nrow = 1)

aux_sign <- sign(colMeans(M))[aux_index]
 
df <- rbind(df,aux_sign)
colnames(df) <- names(aux)
rownames(df) <- c("mean","sign")

df <- as.data.frame(df)

df
# We need to precompute the "error" for the graph. In this case we will use standard deviation:


library(dplyr)
M_sd <- M %>% summarise_if(is.numeric, sd)

my_sd <- as.matrix(M_sd[,names(aux)])

my_sd <- as.vector(my_sd)



data <- data.frame(
  name=names(aux),
  Sign = as.factor(aux_sign),
  value=unname(aux),
  sd=my_sd
)


```

```{r}
# Plot: 
plot_error_bars <- ggplot(data, aes(x=reorder(name, -value), y=value, fill=Sign)) +
    geom_bar( stat="identity", colour = "black",  alpha=1) +
    geom_errorbar( aes(x=name, ymin=value-sd, ymax=value+sd), width=0.3, colour="black", alpha=0.9, size=1.3) + 
    cowplot::theme_half_open()+
    labs(y = "Coefficient (absolute) values", x = "Variables or interactions")+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    theme(legend.position = c(0.5, 0.8), legend.direction = "horizontal") +
    labs(fill = "Coefficient sign")
    

plot_error_bars
```



```{r}
# Save as pdf as eps had problems with the error bars
pdf(file="temporal/fig_Boston_barplot.pdf", width = 2*my_width, height = 1.5*my_width)
plot_error_bars
dev.off()
```








