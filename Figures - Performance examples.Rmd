---
title: "Figures - Performance examples"
author: "Pablo Morala"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

####################################
# 1 - Load all needed packages and functions
####################################
library(nn2poly)
library(nn2poly.tools)
library(keras)
library(tensorflow)
library(cowplot)
library(ggplot2)
library(patchwork)

IEEE_width_inches <- 3.5
my_width <- IEEE_width_inches

my_seed <- 42
set.seed(my_seed)
tensorflow::tf$random$set_seed(my_seed) # Needed to have reproducible results with keras
```


In this Rmd file we are going to plot the figures from the simulations included in `Data - Performance examples.Rmd` to show how to use NN2Poly in 2 different situations with synthetically generated data.

# Example 1 - Performance

```{r}
example1 <- readRDS("temporal/nn_performance_example_l1")
```

```{r}

plot.example <- cowplot::plot_grid(example1$plot_NN_performance, example1$plot_PR_vs_NN + ggplot2::labs(x = "Predicted Y with polynomial"), labels = c("A", "B"), scale = 0.9, label_size = 10)

plot.example

# Save as pdf
pdf(file="temporal/fig_performance_l1.pdf", width = 2*my_width, height = 1*my_width)
plot.example
dev.off()


```




# Example 2 - Performance

```{r}
example2 <- readRDS("temporal/nn_performance_example_nc")
```

```{r}

plot.example <- cowplot::plot_grid(example2$plot_NN_performance, example2$plot_PR_vs_NN + ggplot2::labs(x = "Predicted Y with polynomial"), labels = c("A", "B"), scale = 0.9, label_size = 10)

plot.example

# Save as pdf
pdf(file="temporal/fig_performance_nc.pdf", width = 2*my_width, height = 1*my_width)
plot.example
dev.off()


```


# Taylor layers

```{r}
p1 <- example1$plot_taylor[[1]] 
p2 <- example1$plot_taylor[[2]] 
# + ggtitle('Layer 2') + theme(plot.title = element_text(size = 12, face = "plain")) + theme(legend.position = "none")
p3 <- example1$plot_taylor[[3]] 
# + ggtitle('Layer 3') + theme(plot.title = element_text(size = 12, face = "plain")) + theme(legend.position = "none")

p4 <- example2$plot_taylor[[1]] 
# + ggtitle('Layer 1') + theme(plot.title = element_text(size = 12, face = "plain")) + theme(legend.position = "none")
p5 <- example2$plot_taylor[[2]] 
# + ggtitle('Layer 2') + theme(plot.title = element_text(size = 12, face = "plain")) + theme(legend.position = "none")
p6 <- example2$plot_taylor[[3]] 
# + ggtitle('Layer 3') + theme(plot.title = element_text(size = 12, face = "plain")) + theme(legend.position = "none")
```

```{r, warning=FALSE}
plot_taylor_final <- wrap_plots(p1, p2, p3, p4, p5, p6, ncol=3) + 
  plot_layout(guides="collect") &
  theme(legend.position = "bottom") & 
  scale_color_identity(name = "Legend",
                       breaks = c("black", "red", "blue", "darkgreen"),
                       labels = c("True function","Taylor approximation", "Error", "Activation potentials density (log(x+1) scaled)"),
                       guide = "legend")
plot_taylor_final
```




```{r}
# Save as pdf
pdf(file="temporal/fig_taylor_layers.pdf", width = 3.6*my_width, height = 1.8*my_width)
plot_taylor_final
dev.off()

```




# Coefficients plot example 1 NN with 10 repetitions



```{r}

simulations <- readRDS("data/nn_performance_example_10_repetitions")

n_sims <- length(simulations)

string_labels <- rep("0",length(simulations[[1]]$labels))
for (i in 1:length(simulations[[1]]$labels)) {
    # Create the label as a string of the form "l_1 l_2 ... l_t"
    string_labels[i] <- paste(as.character(simulations[[1]]$labels[[i]]), collapse = ",")
}

M <- matrix(1, n_sims, length(simulations[[1]]$labels))

colnames(M) <- string_labels

for (sim in 1:n_sims){
  coefs <- simulations[[sim]]$values
  
  M[sim, ] <- coefs
}

M <- as.data.frame(M)


n_important <- 10
# perform the mean to obtain the order using the mean:
aux_total <- sort(abs(colMeans(M)),decreasing = TRUE, index.return = TRUE)
aux <- aux_total$x[1:n_important]
aux_index <- aux_total$ix[1:n_important]


df <- matrix(aux, nrow = 1)

aux_sign <- sign(colMeans(M))[aux_index]
 
df <- rbind(df,aux_sign)
colnames(df) <- names(aux)
rownames(df) <- c("mean","sign")

df <- as.data.frame(df)

df
# We need to precompute the "error" for the graph. In this case we will use standard deviation:


library(dplyr)
M_sd <- M %>% summarise_if(is.numeric, sd)

my_sd <- as.matrix(M_sd[,names(aux)])

my_sd <- as.vector(my_sd)



data <- data.frame(
  name=names(aux),
  Sign = as.factor(aux_sign),
  value=unname(aux),
  sd=my_sd
)


```




```{r}
# Plot: 
plot_error_bars <- ggplot(data, aes(x=reorder(name, -value), y=value, fill=Sign)) +
    geom_bar( stat="identity", colour = "black",  alpha=1) +
    geom_errorbar( aes(x=name, ymin=value-sd, ymax=value+sd), width=0.3, colour="black", alpha=0.9, size=1.3) + 
    cowplot::theme_half_open()+
    scale_fill_manual(values = c("#F8766D","#00BA38"), labels = c("-","+"))+
    labs(y = "Coefficient (absolute) values", x = "Variables or interactions")+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    theme(legend.position = c(0.8, 0.8), legend.direction = "vertical") +
    labs(fill = "Sign")
    

plot_error_bars
```


```{r}
# Save as pdf
pdf(file="temporal/fig_coeffs_example1.pdf", width = 2*my_width, height = 1*my_width)
plot_error_bars
dev.off()
```

